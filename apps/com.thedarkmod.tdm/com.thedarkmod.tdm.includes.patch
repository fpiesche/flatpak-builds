diff --git a/framework/Common.cpp b/framework/Common.cpp
index 356ea0a18..0ee667318 100644
--- a/framework/Common.cpp
+++ b/framework/Common.cpp
@@ -2774,8 +2774,10 @@ void idCommonLocal::Init( int argc, const char **argv, const char *cmdline )
 		// init CVar system
 		cvarSystem->Init();
 
+		#ifdef ENABLE_TRACY
 		// potentially start trace profiler if requested
 		InitTracing();
+		#endif
 
 		// start file logging right away, before early console or whatever
 		StartupVariable( "win_outputDebugString", false );
diff --git a/framework/File.cpp b/framework/File.cpp
index bc2e9e18e..dafe70e75 100644
--- a/framework/File.cpp
+++ b/framework/File.cpp
@@ -18,7 +18,7 @@ Project: The Dark Mod (http://www.thedarkmod.com/)
 
 
 
-#include <minizip/unzip.h>
+#include <unzip.h>
 #include "minizip/minizip_extra.h"	//unzSeek
 
 /*
diff --git a/framework/FileSystem.cpp b/framework/FileSystem.cpp
index b3a0e61a5..76ed8c7bd 100644
--- a/framework/FileSystem.cpp
+++ b/framework/FileSystem.cpp
@@ -18,10 +18,10 @@ Project: The Dark Mod (http://www.thedarkmod.com/)
 
 
 
-#include <minizip/unzip.h>
+#include <unzip.h>
 #include "minizip/minizip_extra.h"	//unzReOpen
 //stgatilov: for pk4 repacking
-#include <minizip/zip.h>
+#include <zip.h>
 
 #ifdef WIN32
 	#include <io.h>	// for _read
diff --git a/framework/Tracing.cpp b/framework/Tracing.cpp
index f19932364..916474103 100644
--- a/framework/Tracing.cpp
+++ b/framework/Tracing.cpp
@@ -19,7 +19,9 @@ Project: The Dark Mod (http://www.thedarkmod.com/)
 // stgatilov: if you update Tracy and this header is missing in new artefacts
 // then you need to implement proper way of querying the version of Tracy
 // see this issue: https://github.com/wolfpld/tracy/issues/449
+#ifdef ENABLE_TRACY
 #include <common/TracyVersion.hpp>
+#endif
 
 idCVar r_useDebugGroups(
 	// note: we cannot enable these for players, because they are slow as shit in AMD driver:
diff --git a/framework/Tracing.h b/framework/Tracing.h
index 6a96ee5d5..2aa741907 100644
--- a/framework/Tracing.h
+++ b/framework/Tracing.h
@@ -12,7 +12,6 @@ or (at your option) any later version. For details, see LICENSE.TXT.
 Project: The Dark Mod (http://www.thedarkmod.com/)
 
 ******************************************************************************/
-
 #pragma once
 
 #include "renderer/backend/qgl/qgl.h"
diff --git a/framework/TracingEmbeddedSourceCode.cpp b/framework/TracingEmbeddedSourceCode.cpp
index 5f0c4d957..9bb4cd35e 100644
--- a/framework/TracingEmbeddedSourceCode.cpp
+++ b/framework/TracingEmbeddedSourceCode.cpp
@@ -1 +1,3 @@
+#ifdef ENABLE_TRACY
 #include <TracyClient.cpp>
+#endif
diff --git a/framework/minizip/minizip_extra.h b/framework/minizip/minizip_extra.h
index ad53f4674..27870827f 100644
--- a/framework/minizip/minizip_extra.h
+++ b/framework/minizip/minizip_extra.h
@@ -14,12 +14,13 @@ Project: The Dark Mod (http://www.thedarkmod.com/)
 ******************************************************************************/
 #pragma once
 
-#include <minizip/unzip.h>
+#include <unzip.h>
+#include <zconf.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
-
+
 extern unzFile unzReOpen( const char* path, unzFile file );
 /* Re-Open a Zip file, i.e. clone an existing one and give it a new file descriptor. */
 
diff --git a/idlib/StdFilesystem.cpp b/idlib/StdFilesystem.cpp
index 56d8921f2..6e3b56fa9 100644
--- a/idlib/StdFilesystem.cpp
+++ b/idlib/StdFilesystem.cpp
@@ -20,29 +20,28 @@ Project: The Dark Mod (http://www.thedarkmod.com/)
 	#if _MSC_VER < 1910
 		//STL-based implementation for MSVC2013
 		#include <filesystem>
-		namespace stdfsys = std::tr2::sys;
+		namespace filesystem = std::tr2::sys;
 	#else // MSVC 2017+
 		#if _HAS_CXX17
 			#include <filesystem>
-			namespace stdfsys = std::filesystem;
+			namespace filesystem = filesystem;
 		#else
 			#define _SILENCE_EXPERIMENTAL_FILESYSTEM_DEPRECATION_WARNING
 			#include <experimental/filesystem>
-			namespace stdfsys = std::experimental::filesystem;
+			namespace filesystem = std::experimental::filesystem;
 		#endif
 	#endif 
 #else
 	//it should be here for both GCC and Clang
-	#include <experimental/filesystem>
-	namespace stdfsys = std::experimental::filesystem::v1;
+	#include <filesystem>
 #endif
 
 namespace stdext {
-	struct path_impl : public stdfsys::path {
-		path_impl() : stdfsys::path() {}
-		path_impl(const char* str) : stdfsys::path(str) {}
-		path_impl(const std::string &str) : stdfsys::path(str) {}
-		path_impl(const stdfsys::path &path) : stdfsys::path(path) {}
+	struct path_impl : public filesystem::path {
+		path_impl() : filesystem::path() {}
+		path_impl(const char* str) : filesystem::path(str) {}
+		path_impl(const std::string &str) : filesystem::path(str) {}
+		path_impl(const filesystem::path &path) : filesystem::path(path) {}
 	};
 	path_impl &get(path &path) {
 		return *path.d;
@@ -104,62 +103,62 @@ namespace stdext {
 
 	bool is_directory(const path &path) {
 		bool res;
-		try {	res = stdfsys::is_directory(get(path)); }
-		catch(stdfsys::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
+		try {	res = filesystem::is_directory(get(path)); }
+		catch(filesystem::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
 		return res;
 	}
 	bool create_directory(const path &path) {
 		bool res;
-		try {	res = stdfsys::create_directory(get(path)); }
-		catch(stdfsys::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
+		try {	res = filesystem::create_directory(get(path)); }
+		catch(filesystem::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
 		return res;
 	}
 	bool exists(const path &path) {
 		bool res;
-		try {	res = stdfsys::exists(get(path)); }
-		catch(stdfsys::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
+		try {	res = filesystem::exists(get(path)); }
+		catch(filesystem::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
 		return res;
 	}
 	bool create_directories(const path &path) {
 		bool res;
-		try {	res = stdfsys::create_directories(get(path)); }
-		catch(stdfsys::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
+		try {	res = filesystem::create_directories(get(path)); }
+		catch(filesystem::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
 		return res;
 	}
 	bool remove(const path &path) {
 		bool res;
-		try {	res = stdfsys::remove(get(path)); }
-		catch(stdfsys::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
+		try {	res = filesystem::remove(get(path)); }
+		catch(filesystem::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
 		return res;
 	}
 	uint64_t file_size(const path &path) {
 		uint64_t res;
-		try {	res = stdfsys::file_size(get(path)); }
-		catch(stdfsys::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
+		try {	res = filesystem::file_size(get(path)); }
+		catch(filesystem::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
 		return res;
 	}
 	uint64_t remove_all(const path& path) {
 		uint64_t res;
-		try {	res = stdfsys::remove_all(get(path)); }
-		catch(stdfsys::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
+		try {	res = filesystem::remove_all(get(path)); }
+		catch(filesystem::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
 		return res;
 	}
 	void copy_file(const path &from, const path &to) {
-		try {	stdfsys::copy_file(get(from), get(to)); }
-		catch(stdfsys::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
+		try {	filesystem::copy_file(get(from), get(to)); }
+		catch(filesystem::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
 	}
 	void rename(const path &from, const path &to) {
-		try {	stdfsys::rename(get(from), get(to)); }
-		catch(stdfsys::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
+		try {	filesystem::rename(get(from), get(to)); }
+		catch(filesystem::filesystem_error &e) { throw filesystem_error(e.what(), e.code()); }
 	}
 
 	std::vector<path> directory_enumerate(const path &rootPath) {
 		std::vector<path> res;
 		try {
-			for (auto iter = stdfsys::directory_iterator(get(rootPath)); iter != stdfsys::directory_iterator(); ++iter)
+			for (auto iter = filesystem::directory_iterator(get(rootPath)); iter != filesystem::directory_iterator(); ++iter)
 				res.push_back(path_impl(iter->path()));
 		}
-		catch(stdfsys::filesystem_error &e) {
+		catch(filesystem::filesystem_error &e) {
 			throw filesystem_error(e.what(), e.code());
 		}
 		return res;
@@ -167,10 +166,10 @@ namespace stdext {
 	std::vector<path> recursive_directory_enumerate(const path &rootPath) {
 		std::vector<path> res;
 		try {
-			for (auto iter = stdfsys::recursive_directory_iterator(get(rootPath)); iter != stdfsys::recursive_directory_iterator(); ++iter)
+			for (auto iter = filesystem::recursive_directory_iterator(get(rootPath)); iter != filesystem::recursive_directory_iterator(); ++iter)
 				res.push_back(path_impl(iter->path()));
 		}
-		catch(stdfsys::filesystem_error &e) {
+		catch(filesystem::filesystem_error &e) {
 			throw filesystem_error(e.what(), e.code());
 		}
 		return res;
